<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Google zx 中文版 | 中文 front-end tech</title>
    <meta name="description" content="中文 description">
    <link rel="stylesheet" href="/vitepress-blog/assets/style.49eed234.css">
    <link rel="modulepreload" href="/vitepress-blog/assets/Home.d427a49b.js">
    <link rel="modulepreload" href="/vitepress-blog/assets/rm-rf2.c98785e5.js">
    <link rel="modulepreload" href="/vitepress-blog/assets/app.f6226b5c.js">
    <link rel="modulepreload" href="/vitepress-blog/assets/index.md.a4942220.lean.js">
    
    <meta name="twitter:title" content="Google zx 中文版 | 中文 front-end tech">
  <meta property="og:title" content="Google zx 中文版 | 中文 front-end tech">
  </head>
  <body>
    <div id="app"><!--[--><div class="theme"><header class="nav-bar" data-v-675d8756><div class="sidebar-button" data-v-675d8756><svg class="icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z" class></path></svg></div><a class="nav-bar-title" href="/vitepress-blog/" aria-label="中文 front-end tech, back to home" data-v-675d8756 data-v-cc01ef16><!----> 中文 front-end tech</a><div class="flex-grow" data-v-675d8756></div><div class="nav" data-v-675d8756><nav class="nav-links" data-v-675d8756 data-v-eab3edfe><!--[--><div class="item" data-v-eab3edfe><div class="nav-link" data-v-eab3edfe data-v-b8818f8c><a class="item active" href="/vitepress-blog/zh" data-v-b8818f8c>zx <!----></a></div></div><!--]--><div class="item" data-v-eab3edfe><div class="nav-dropdown-link" data-v-eab3edfe data-v-56bf3a3f><button class="button" data-v-56bf3a3f><span class="button-text" data-v-56bf3a3f>Languages</span><span class="right button-arrow" data-v-56bf3a3f></span></button><ul class="dialog" data-v-56bf3a3f><!--[--><li class="dialog-item" data-v-56bf3a3f><div class="nav-dropdown-link-item" data-v-56bf3a3f data-v-bbc27490><a class="item" href="/vitepress-blog/index.html" data-v-bbc27490><span class="arrow" data-v-bbc27490></span><span class="text" data-v-bbc27490>中文</span><span class="icon" data-v-bbc27490><!----></span></a></div></li><li class="dialog-item" data-v-56bf3a3f><div class="nav-dropdown-link-item" data-v-56bf3a3f data-v-bbc27490><a class="item" href="/vitepress-blog/en/index.html" data-v-bbc27490><span class="arrow" data-v-bbc27490></span><span class="text" data-v-bbc27490>English</span><span class="icon" data-v-bbc27490><!----></span></a></div></li><!--]--></ul></div></div><!----></nav></div><!--[--><!--]--></header><aside class="sidebar" data-v-83e92a68><nav class="nav-links nav" data-v-83e92a68 data-v-eab3edfe><!--[--><div class="item" data-v-eab3edfe><div class="nav-link" data-v-eab3edfe data-v-b8818f8c><a class="item active" href="/vitepress-blog/zh" data-v-b8818f8c>zx <!----></a></div></div><!--]--><div class="item" data-v-eab3edfe><div class="nav-dropdown-link" data-v-eab3edfe data-v-56bf3a3f><button class="button" data-v-56bf3a3f><span class="button-text" data-v-56bf3a3f>Languages</span><span class="right button-arrow" data-v-56bf3a3f></span></button><ul class="dialog" data-v-56bf3a3f><!--[--><li class="dialog-item" data-v-56bf3a3f><div class="nav-dropdown-link-item" data-v-56bf3a3f data-v-bbc27490><a class="item" href="/vitepress-blog/index.html" data-v-bbc27490><span class="arrow" data-v-bbc27490></span><span class="text" data-v-bbc27490>中文</span><span class="icon" data-v-bbc27490><!----></span></a></div></li><li class="dialog-item" data-v-56bf3a3f><div class="nav-dropdown-link-item" data-v-56bf3a3f data-v-bbc27490><a class="item" href="/vitepress-blog/en/index.html" data-v-bbc27490><span class="arrow" data-v-bbc27490></span><span class="text" data-v-bbc27490>English</span><span class="icon" data-v-bbc27490><!----></span></a></div></li><!--]--></ul></div></div><!----></nav><!--[--><!--]--><ul class="sidebar-links" data-v-83e92a68><!--[--><li class="sidebar-link"><a class="sidebar-link-item" href="#简介">简介</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#背景">背景</a><ul class="sidebar-links"><li class="sidebar-link"><a class="sidebar-link-item" href="#扔砖引玉">扔砖引玉</a><!----></li></ul></li><li class="sidebar-link"><a class="sidebar-link-item" href="#历史">历史</a><ul class="sidebar-links"><li class="sidebar-link"><a class="sidebar-link-item" href="#使用javascript写shell脚本">使用javascript写shell脚本</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#原生方式child-process">原生方式child_process</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#shelljs执行linux命令行">shelljs执行linux命令行</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#用spawn-来编写跨平台-node-js命令">用spawn 来编写跨平台 Node.js命令</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#部分资料参考">部分资料参考</a><!----></li></ul></li><!--]--></ul><!--[--><!--]--></aside><div class="sidebar-mask"></div><main class="page" data-v-7eddb2c4><div class="container" data-v-7eddb2c4><!--[--><!--]--><div style="position:relative;" class="content" data-v-7eddb2c4><div><h1 id="google-zx-中文版" tabindex="-1">Google zx 中文版 <a class="header-anchor" href="#google-zx-中文版" aria-hidden="true">#</a></h1><img src="/vitepress-blog/assets/programmer-5-years.4deb7709.png" style="width:auto;height:auto;"><h2 id="简介" tabindex="-1">简介 <a class="header-anchor" href="#简介" aria-hidden="true">#</a></h2><p><a href="https://anprettyboy.github.io/handsome-man/" target="_blank" rel="noopener noreferrer">2021年度最流行项目</a>是<a href="https://github.com/google/zx" target="_blank" rel="noopener noreferrer">zx</a>，一个由谷歌推出的全新的工具，可用于以 JavaScript 或 TypeScript 编写简单的命令行脚本。</p><p>基本上它可以让你在代码中嵌入任何 bash 表达式（ls, cat, git...等任何命令！），并通过<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/await" target="_blank" rel="noopener noreferrer">await操作符</a>使用<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals" target="_blank" rel="noopener noreferrer">JavaScript template literals</a>的结果。</p><p>它引入了由几个流行的软件包提供的实用工具：</p><ul><li><a href="https://github.com/node-fetch/node-fetch" target="_blank" rel="noopener noreferrer">node-fetch</a> 与浏览器中<a href="https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API" target="_blank" rel="noopener noreferrer">Fetch</a>有着相同的 API， 可创建 HTTP 请求。</li><li><a href="https://github.com/jprichardson/node-fs-extra" target="_blank" rel="noopener noreferrer">fs-extra</a> 可处理文件系统操作。</li><li><a href="https://github.com/sindresorhus/globby" target="_blank" rel="noopener noreferrer">globby</a> 以用户友好模式来匹配给定的文件名。</li></ul><h2 id="背景" tabindex="-1">背景 <a class="header-anchor" href="#背景" aria-hidden="true">#</a></h2><p>&quot;Bash 很棒，但是在编写脚本时，人们通常会选择更方便的编程语言。 JavaScript 是一个完美的选择，但标准的 Node.js 库在使用之前需要额外的麻烦。 zx 包提供了围绕 child_process 的有用包装器，转义参数并提供合理的默认值。&quot;</p><h3 id="扔砖引玉" tabindex="-1">扔砖引玉 <a class="header-anchor" href="#扔砖引玉" aria-hidden="true">#</a></h3><img src="/vitepress-blog/assets/rm-rf2.748d5332.jpeg" style="width:auto;height:auto;"><p>&quot;想象一下，你本来想删除：rm -rf $dir/<em>然后dir是空的时候，变成了什么？rm -rf是删除命令，$dir是空的话，相当于执行 rm -rf /</em>,这是删除所有文件和文件夹。。。然后，你的系统就没了，这就是传说中的删库跑路吗~~~~&quot;</p><h2 id="历史" tabindex="-1">历史 <a class="header-anchor" href="#历史" aria-hidden="true">#</a></h2><img src="/vitepress-blog/assets/change.36926f2b.png" style="width:auto;height:auto;"><h3 id="使用javascript写shell脚本" tabindex="-1">使用javascript写shell脚本 <a class="header-anchor" href="#使用javascript写shell脚本" aria-hidden="true">#</a></h3><p>#! 是一个约定的标记，它告诉系统这个脚本需要什么解释器来运行，即：使用哪一种 shell。#!被称为<a href="https://zh.wikipedia.org/wiki/Shebang" target="_blank" rel="noopener noreferrer">shebang（也称为 Hashbang）</a>,例如使用 bash：#! /bin/bash</p><p>最简单的脚本</p><div class="language-shell"><pre><code><span class="token shebang important">#!/usr/bin/env node</span>
console.log<span class="token punctuation">(</span><span class="token string">&#39;hello world&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>保存为test，执行该脚本 node test,然后可以在控制台获得输出。</p><p>更进一步，我们给该脚本一个执行权限，</p><div class="language-shell"><pre><code><span class="token function">chmod</span> <span class="token number">755</span> <span class="token builtin class-name">test</span>
</code></pre></div><h4 id="例子-读取给定文件夹下所有的文件" tabindex="-1">例子-读取给定文件夹下所有的文件 <a class="header-anchor" href="#例子-读取给定文件夹下所有的文件" aria-hidden="true">#</a></h4><p>读取当前文件夹使用 fs.readdirSync方法，该方法会返回一个数组，包含了给定文件夹下的所有子文件夹或文件,</p><p>举个栗子，在当前目录我有个test文件夹</p><div class="language-shell"><pre><code><span class="token builtin class-name">test</span>
├── <span class="token number">1</span>.html
├── <span class="token number">1</span>.txt
└── files
</code></pre></div><p>fs.readdirSync(&#39;./test&#39;) 的输出为 [ &#39;1.html&#39;, &#39;1.txt&#39;, &#39;files&#39; ]</p><p>新建个文件，getFile，用来存放脚本代码</p><h4 id="写死的文件夹" tabindex="-1">写死的文件夹 <a class="header-anchor" href="#写死的文件夹" aria-hidden="true">#</a></h4><p>读取给定目录下所有文件并输出的代码如下：</p><div class="language-shell"><pre><code><span class="token shebang important">#!/usr/bin/env node</span>

const testFolder <span class="token operator">=</span> <span class="token string">&#39;./test/&#39;</span><span class="token punctuation">;</span>
const fs <span class="token operator">=</span> require<span class="token punctuation">(</span><span class="token string">&#39;fs&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

fs.readdirSync<span class="token punctuation">(</span>testFolder<span class="token punctuation">)</span>.forEach<span class="token punctuation">(</span>file <span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span>
  console.log<span class="token punctuation">(</span>file<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><h4 id="获取用户输入" tabindex="-1">获取用户输入 <a class="header-anchor" href="#获取用户输入" aria-hidden="true">#</a></h4><p>以上代码的给定的路径是写死的，我们需要作为参数输入，nodejs读取用户输入的方法:</p><div class="language-shell"><pre><code>const <span class="token punctuation">[</span>nodeEnv,dir,<span class="token punctuation">..</span>.args<span class="token punctuation">]</span><span class="token operator">=</span>process.argv //args是用户输入的参数
</code></pre></div><p>修改脚本代码：</p><div class="language-shell"><pre><code><span class="token shebang important">#!/usr/bin/env node</span>

const fs <span class="token operator">=</span> require<span class="token punctuation">(</span><span class="token string">&#39;fs&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
const <span class="token punctuation">[</span>nodeEnv,dir,<span class="token punctuation">..</span>.args<span class="token punctuation">]</span><span class="token operator">=</span>process.argv

// 获取用户输入的路径
const <span class="token assign-left variable">folder</span><span class="token operator">=</span>args<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>

fs.readdirSync<span class="token punctuation">(</span>folder<span class="token punctuation">)</span>.forEach<span class="token punctuation">(</span>file <span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span>
  console.log<span class="token punctuation">(</span>file<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>现在执行脚本时，路径就可以自己输入了</p><div class="language-shell"><pre><code><span class="token function">node</span> getFile 你的路径
</code></pre></div><h3 id="原生方式child-process" tabindex="-1">原生方式child_process <a class="header-anchor" href="#原生方式child-process" aria-hidden="true">#</a></h3><p>nodejs可以使用child_process模块新建子进程，用来执行unit系统命令，写个测试的例子，如下所示：</p><div class="language-shell"><pre><code><span class="token shebang important">#!/usr/bin/env node</span>


//-----同步写法👇
const <span class="token assign-left variable">execSync</span><span class="token operator">=</span>require<span class="token punctuation">(</span><span class="token string">&#39;child_process&#39;</span><span class="token punctuation">)</span>.execSync

const <span class="token assign-left variable">res</span><span class="token operator">=</span>execSync<span class="token punctuation">(</span><span class="token string">&#39;ls&#39;</span><span class="token punctuation">)</span>
console.log<span class="token punctuation">(</span><span class="token string">&quot;res&quot;</span>, res.toString<span class="token punctuation">(</span><span class="token punctuation">))</span>


// ----- 异步写法👇
const <span class="token assign-left variable">exec</span><span class="token operator">=</span>require<span class="token punctuation">(</span><span class="token string">&#39;child_process&#39;</span><span class="token punctuation">)</span>.exec
exec<span class="token punctuation">(</span><span class="token string">&#39;ls&#39;</span>,<span class="token punctuation">(</span>err,stdout,stderr<span class="token punctuation">)</span><span class="token operator">=</span><span class="token operator">&gt;</span><span class="token punctuation">{</span>
   if<span class="token punctuation">(</span>err<span class="token punctuation">)</span>throw err
   console.log<span class="token punctuation">(</span>stdout<span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div><h3 id="shelljs执行linux命令行" tabindex="-1">shelljs执行linux命令行 <a class="header-anchor" href="#shelljs执行linux命令行" aria-hidden="true">#</a></h3><p>首先需要安装shelljs</p><div class="language-"><pre><code>npm i shelljs -S
</code></pre></div><p>shelljs提供了很多方法，最常用的是exec，举个栗子</p><div class="language-shell"><pre><code>const <span class="token assign-left variable">shell</span><span class="token operator">=</span>require<span class="token punctuation">(</span><span class="token string">&#39;shelljs&#39;</span><span class="token punctuation">)</span>
/**
 * 函数签名：exec<span class="token punctuation">(</span>command <span class="token punctuation">[</span>, options<span class="token punctuation">]</span> <span class="token punctuation">[</span>, callback<span class="token punctuation">]</span><span class="token punctuation">)</span>
 * command:要执行的命令
 * callback:回调函数，对command的输出进行处理
 * options:
 *  async: 异步执行.如果callback提供了，会忽略该参数并强制异步执行  <span class="token punctuation">(</span>default: <span class="token boolean">false</span><span class="token punctuation">)</span>
 *  fatal: Exit upon error <span class="token punctuation">(</span>default: <span class="token boolean">false</span><span class="token punctuation">)</span>.
 *  silent: 不在console中输出<span class="token punctuation">(</span>default: <span class="token boolean">false</span><span class="token punctuation">)</span>.
 *  encoding: 设置stdout和stderr的编码 <span class="token punctuation">(</span>default: <span class="token string">&#39;utf8&#39;</span><span class="token punctuation">)</span>
 */

//输出ls的结果
shell.exec<span class="token punctuation">(</span><span class="token string">&quot;ls&quot;</span><span class="token punctuation">)</span>

//callback<span class="token punctuation">(</span>code,stdout,stderr<span class="token punctuation">)</span>  code为0则成功，否则失败
shell.exec<span class="token punctuation">(</span><span class="token string">&quot;dir&quot;</span>,<span class="token punctuation">{</span>silent:true<span class="token punctuation">}</span>,<span class="token punctuation">(</span>code,stdout,stderr<span class="token punctuation">)</span><span class="token operator">=</span><span class="token operator">&gt;</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span>

shell.exec<span class="token punctuation">(</span><span class="token string">&#39;ls&#39;</span>,<span class="token punctuation">{</span>silent:true<span class="token punctuation">}</span>,<span class="token punctuation">(</span>code,stdout,stderr<span class="token punctuation">)</span><span class="token operator">=</span><span class="token operator">&gt;</span><span class="token punctuation">{</span>
    console.log<span class="token punctuation">(</span>code<span class="token punctuation">)</span>
    console.log<span class="token punctuation">(</span>stdout<span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div><img src="/vitepress-blog/assets/computer-learn.0cde64fa.jpeg" style="width:auto;height:auto;"><p>在开发过程中，常会遇到如下命令：</p><div class="language-shell"><pre><code><span class="token function">git</span> <span class="token function">add</span> <span class="token builtin class-name">.</span>
<span class="token function">git</span> commit -m <span class="token string">&#39;*****&#39;</span>
<span class="token function">git</span> push
</code></pre></div><ol><li>在根目录下新建文件shell.js，内容如下：</li></ol><div class="language-shell"><pre><code><span class="token builtin class-name">let</span> shell <span class="token operator">=</span> require<span class="token punctuation">(</span><span class="token string">&#39;shelljs&#39;</span><span class="token punctuation">)</span>
<span class="token builtin class-name">let</span> name <span class="token operator">=</span> process.argv<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">||</span> <span class="token string">&#39;Auto-commit&#39;</span><span class="token punctuation">;</span>
<span class="token builtin class-name">let</span> <span class="token builtin class-name">exec</span> <span class="token operator">=</span> shell.exec

<span class="token keyword">if</span> <span class="token punctuation">(</span>exec<span class="token punctuation">(</span><span class="token string">&#39;git add .&#39;</span><span class="token punctuation">)</span>.code <span class="token operator">!=</span><span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    echo<span class="token punctuation">(</span><span class="token string">&#39;Error: Git add failed&#39;</span><span class="token punctuation">)</span>
    exit<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>exec<span class="token punctuation">(</span><span class="token variable"><span class="token variable">`</span><span class="token function">git</span> commit -am <span class="token string">&quot;<span class="token variable">${name}</span>&quot;</span><span class="token variable">`</span></span><span class="token punctuation">)</span>.code <span class="token operator">!=</span><span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    echo<span class="token punctuation">(</span><span class="token string">&#39;Error: Git commit failed&#39;</span><span class="token punctuation">)</span>
    exit<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>exec<span class="token punctuation">(</span><span class="token string">&#39;git push&#39;</span><span class="token punctuation">)</span>.code <span class="token operator">!=</span><span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    echo<span class="token punctuation">(</span><span class="token string">&#39;Error: Git commit failed&#39;</span><span class="token punctuation">)</span>
    exit<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><ol start="2"><li>只用一条命令执行以上所有任务，在package.json中加入,方法如下:</li></ol><div class="language-shell"><pre><code><span class="token string">&quot;script&quot;</span>:<span class="token punctuation">{</span>
    <span class="token string">&quot;push&quot;</span><span class="token builtin class-name">:</span><span class="token string">&quot;node ./shell.js&quot;</span>
<span class="token punctuation">}</span>
</code></pre></div><ol start="3"><li>执行</li></ol><div class="language-shell"><pre><code><span class="token function">npm</span> run push 测试shelljs提交代码
</code></pre></div><h3 id="用spawn-来编写跨平台-node-js命令" tabindex="-1">用spawn 来编写跨平台 Node.js命令 <a class="header-anchor" href="#用spawn-来编写跨平台-node-js命令" aria-hidden="true">#</a></h3><p>如果想要编写跨平台的 spawn 命令，而又不想增加额外的开销的话，可以这样写</p><div class="language-shell"><pre><code>const process <span class="token operator">=</span> require<span class="token punctuation">(</span><span class="token string">&#39;process&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
const <span class="token punctuation">{</span> spawn <span class="token punctuation">}</span> <span class="token operator">=</span> require<span class="token punctuation">(</span><span class="token string">&#39;child_process&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

spawn<span class="token punctuation">(</span><span class="token string">&#39;npm&#39;</span>, <span class="token punctuation">{</span>
 stdio: <span class="token string">&#39;inherit&#39;</span>,
 // 仅在当前运行环境为 Windows 时，才使用 shell
 shell: process.platform <span class="token operator">==</span><span class="token operator">=</span> <span class="token string">&#39;win32&#39;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

</code></pre></div><h4 id="cross-spawn第三方模块" tabindex="-1">cross-spawn第三方模块 <a class="header-anchor" href="#cross-spawn第三方模块" aria-hidden="true">#</a></h4><p>关于 spawn 函数的跨平台写法，除了自己编写代码的时候做处理，也有第三方模块封装好了相关细节，如 cross-spawn。</p><p>使用该模块，可以在调用 spawn 函数时，自动根据当前的运行平台，来决定是否生成一个 shell 来执行所给的命令。对命令和参数中的字符进行转义更为方便。</p><img src="/vitepress-blog/assets/avoid-rm.bac3b5ca.jpeg" style="width:auto;height:auto;"> ### Google zx <p>“Bash很好，所以我选择JavaScript”</p><p>前端开发拿手的不就是 Javascript, 嗯 开整</p><h4 id="安装和使用" tabindex="-1">安装和使用 <a class="header-anchor" href="#安装和使用" aria-hidden="true">#</a></h4><div class="language-shell"><pre><code><span class="token function">npm</span> i -g zx
</code></pre></div><p>安装好 zx 之后，将编写的脚本放在 .mjs 后缀的文件中，或者使用 .js 后缀，但是需要使用 void async function () {...}() 对脚本进行包装。</p><p>使用时需注意以下几点：</p><h4 id="_1、脚本需要包含以下文件头：" tabindex="-1">1、脚本需要包含以下文件头： <a class="header-anchor" href="#_1、脚本需要包含以下文件头：" aria-hidden="true">#</a></h4><div class="language-"><pre><code>#!/usr/bin/env zx
</code></pre></div><h4 id="_2-为脚本添加执行权限再运行" tabindex="-1">2. 为脚本添加执行权限再运行 <a class="header-anchor" href="#_2-为脚本添加执行权限再运行" aria-hidden="true">#</a></h4><div class="language-"><pre><code>$ chmod +x ./script.mjs
$ ./script.mjs

# 或者使用这个命令
$ zx ./script.mjs
</code></pre></div><h4 id="zx-常用命令" tabindex="-1">zx 常用命令 <a class="header-anchor" href="#zx-常用命令" aria-hidden="true">#</a></h4><h5 id="command" tabindex="-1">$<code>command</code> <a class="header-anchor" href="#command" aria-hidden="true">#</a></h5><p>使用 child_process 包中提供的 exec 函数，可以把字符串当做命令执行，并返回一个 Promise(ProcessOutput) 对象。通过的一切${...}都会被自动转义和引用。</p><div class="language-shell"><pre><code><span class="token builtin class-name">let</span> count <span class="token operator">=</span> parseInt<span class="token punctuation">(</span>await $<span class="token variable"><span class="token variable">`</span><span class="token function">ls</span> -1 <span class="token operator">|</span> <span class="token function">wc</span> -l<span class="token variable">`</span></span><span class="token punctuation">)</span>
console.log<span class="token punctuation">(</span><span class="token variable"><span class="token variable">`</span>Files count: $<span class="token punctuation">{</span>count<span class="token punctuation">}</span><span class="token variable">`</span></span><span class="token punctuation">)</span>
</code></pre></div><p>要并行上传文件，可以使用下面的脚本：</p><div class="language-shell"><pre><code><span class="token builtin class-name">let</span> hosts <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">..</span>.<span class="token punctuation">]</span>
await Promise.all<span class="token punctuation">(</span>hosts.map<span class="token punctuation">(</span>host <span class="token operator">=</span><span class="token operator">&gt;</span>
  $<span class="token variable"><span class="token variable">`</span><span class="token function">rsync</span> -azP ./src $<span class="token punctuation">{</span>host<span class="token punctuation">}</span>:/var/www<span class="token variable">`</span></span>
<span class="token punctuation">))</span>
</code></pre></div><p>要修改工作路径，可以使用 cd() 方法：</p><div class="language-shell"><pre><code>cd<span class="token punctuation">(</span><span class="token string">&#39;/tmp&#39;</span><span class="token punctuation">)</span>
// 将输出 /tmp
await $<span class="token variable"><span class="token variable">`</span><span class="token builtin class-name">pwd</span><span class="token variable">`</span></span>
</code></pre></div><p>fetch() 方法是对 node-fetch 包的包装：</p><div class="language-shell"><pre><code><span class="token builtin class-name">let</span> resp <span class="token operator">=</span> await fetch<span class="token punctuation">(</span><span class="token string">&#39;http://wttr.in&#39;</span><span class="token punctuation">)</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>resp.ok<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console.log<span class="token punctuation">(</span>await resp.text<span class="token punctuation">(</span><span class="token punctuation">))</span>
<span class="token punctuation">}</span>
</code></pre></div><p>question() 方法是对 readline 包的包装：</p><div class="language-shell"><pre><code><span class="token builtin class-name">type</span> QuestionOptions <span class="token operator">=</span> <span class="token punctuation">{</span> choices: string<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token punctuation">}</span>
<span class="token keyword">function</span> question<span class="token punctuation">(</span>query: string, options?: QuestionOptions<span class="token punctuation">)</span>: Promise<span class="token operator">&lt;</span>string<span class="token operator">&gt;</span>
</code></pre></div><p>用法：</p><div class="language-shell"><pre><code><span class="token builtin class-name">let</span> username <span class="token operator">=</span> await question<span class="token punctuation">(</span><span class="token string">&#39;What is your username? &#39;</span><span class="token punctuation">)</span>
<span class="token builtin class-name">let</span> token <span class="token operator">=</span> await question<span class="token punctuation">(</span><span class="token string">&#39;Choose env variable: &#39;</span>, <span class="token punctuation">{</span>
  choices: Object.keys<span class="token punctuation">(</span>process.<wbr>env<span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div><p>对于 chalk 包，不需要导入就可以直接用：</p><div class="language-shell"><pre><code>console.log<span class="token punctuation">(</span>chalk.blue<span class="token punctuation">(</span><span class="token string">&#39;Hello world!&#39;</span><span class="token punctuation">))</span>
</code></pre></div><p>fs 包，导入就可以直接用：</p><div class="language-shell"><pre><code><span class="token builtin class-name">let</span> content <span class="token operator">=</span> await fs.readFile<span class="token punctuation">(</span><span class="token string">&#39;./package.json&#39;</span><span class="token punctuation">)</span>
</code></pre></div><p>Promisified 默认被引入了，等同于以下代码：</p><div class="language-shell"><pre><code><span class="token function">import</span> <span class="token punctuation">{</span>promises as fs<span class="token punctuation">}</span> from <span class="token string">&#39;fs&#39;</span>
</code></pre></div><p>os 包，导入就可以直接用：</p><div class="language-shell"><pre><code>await $<span class="token variable"><span class="token variable">`</span><span class="token builtin class-name">cd</span> $<span class="token punctuation">{</span>os.homedir<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span> <span class="token operator">&amp;&amp;</span> <span class="token function">mkdir</span> example<span class="token variable">`</span></span>
</code></pre></div><p>zx 还可以从其他脚本导入：</p><div class="language-shell"><pre><code><span class="token shebang important">#!/usr/bin/env node</span>
<span class="token function">import</span> <span class="token punctuation">{</span>$<span class="token punctuation">}</span> from <span class="token string">&#39;zx&#39;</span>
await $<span class="token variable"><span class="token variable">`</span><span class="token function">date</span><span class="token variable">`</span></span>
</code></pre></div><p>传递环境变量：</p><div class="language-shell"><pre><code>process.<wbr>env.FOO <span class="token operator">=</span> <span class="token string">&#39;bar&#39;</span>
await $<span class="token variable"><span class="token variable">`</span><span class="token builtin class-name">echo</span> $FOO<span class="token variable">`</span></span>
</code></pre></div><p>执行远程脚本：</p><div class="language-shell"><pre><code>zx https://your-remote-server.com/example-script.mjs
</code></pre></div><h3 id="部分资料参考" tabindex="-1">部分资料参考 <a class="header-anchor" href="#部分资料参考" aria-hidden="true">#</a></h3><ul><li><a href="https://www.sitepoint.com/google-zx-write-node-shell-scripts/" target="_blank" rel="noopener noreferrer">How to Write Shell Scripts in Node with Google’s zx Library</a></li><li><a href="https://juejin.cn/post/6987307041321091079" target="_blank" rel="noopener noreferrer">shelljs前端自动化</a></li><li><a href="https://juejin.cn/post/6992743763844005902" target="_blank" rel="noopener noreferrer">使用javascript写shell脚本</a></li><li><a href="https://juejin.cn/post/6979989936137043999" target="_blank" rel="noopener noreferrer">nodejs写bash脚本终极方案！</a></li><li><a href="https://juejin.cn/post/7048286354861457416" target="_blank" rel="noopener noreferrer">ZX 用JavaScript写bash脚本</a></li><li><a href="https://juejin.cn/post/6979989936137043999#heading-4" target="_blank" rel="noopener noreferrer">nodejs写bash脚本终极方案！</a></li><li><a href="https://juejin.cn/post/7011464539141046279" target="_blank" rel="noopener noreferrer">zx, 如何用Javascript优雅的书写脚本命令</a></li><li><a href="https://juejin.cn/post/7002536429314277384" target="_blank" rel="noopener noreferrer">Google zx 源码浅析</a></li><li><a href="https://atomcloud.cn/google-script-tool-zx/" target="_blank" rel="noopener noreferrer">Google 脚本工具 zx 使用教程</a></li><li><a href="https://www.sitepoint.com/google-zx-write-node-shell-scripts/" target="_blank" rel="noopener noreferrer">How to Write Shell Scripts in Node with Google’s zx Library</a></li><li><a href="https://www.infoq.com/news/2021/05/zx-javascript-cli-scripts/" target="_blank" rel="noopener noreferrer">Zx - a Tool for Writing Better Scripts</a></li><li><a href="https://blog.tericcabrel.com/write-a-better-bash-script-with-zx/" target="_blank" rel="noopener noreferrer">Write better bash scripts with Zx</a></li><li><a href="https://blog.mastykarz.nl/create-scripts-javascript-zx/" target="_blank" rel="noopener noreferrer">Create scripts in JavaScript with zx</a></li><li><a href="https://www.mo4tech.com/google-zx-source-code-analysis.html" target="_blank" rel="noopener noreferrer">Google ZX source code analysis</a></li></ul></div></div><footer class="page-footer" data-v-7eddb2c4 data-v-fb8d84c6><div class="edit" data-v-fb8d84c6><div class="edit-link" data-v-fb8d84c6 data-v-1ed99556><!----></div></div><div class="updated" data-v-fb8d84c6><p class="last-updated" data-v-fb8d84c6 data-v-5797b537><span class="prefix" data-v-5797b537>Last Updated:</span><span class="datetime" data-v-5797b537></span></p></div></footer><!----><!--[--><!--]--></div></main></div><!----><!--]--></div>
    <script>__VP_HASH_MAP__ = JSON.parse("{\"en.md\":\"6c014f35\",\"index.md\":\"a4942220\"}")</script>
    <script type="module" async src="/vitepress-blog/assets/app.f6226b5c.js"></script>
    
  </body>
</html>